{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar support = require('./support');\n\nvar nodeBuffer = require('./nodeBuffer');\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\n\n\nvar _utf8len = new Array(256);\n\nfor (var i = 0; i < 256; i++) {\n  _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n}\n\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n// convert string to array (typed, when possible)\n\nvar string2buf = function (str) {\n  var buf,\n      c,\n      c2,\n      m_pos,\n      i,\n      str_len = str.length,\n      buf_len = 0; // count binary size\n\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  } // allocate buffer\n\n\n  if (support.uint8array) {\n    buf = new Uint8Array(buf_len);\n  } else {\n    buf = new Array(buf_len);\n  } // convert\n\n\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n\n    if ((c & 0xfc00) === 0xd800 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n\n  return buf;\n}; // Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\n\n\nvar utf8border = function (buf, max) {\n  var pos;\n  max = max || buf.length;\n\n  if (max > buf.length) {\n    max = buf.length;\n  } // go back from last position, until start of sequence found\n\n\n  pos = max - 1;\n\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) {\n    pos--;\n  } // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n\n\n  if (pos < 0) {\n    return max;\n  } // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n\n\n  if (pos === 0) {\n    return max;\n  }\n\n  return pos + _utf8len[buf[pos]] > max ? pos : max;\n}; // convert array to string\n\n\nvar buf2string = function (buf) {\n  var str, i, out, c, c_len;\n  var len = buf.length; // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++]; // quick process ascii\n\n    if (c < 0x80) {\n      utf16buf[out++] = c;\n      continue;\n    }\n\n    c_len = _utf8len[c]; // skip 5 & 6 byte codes\n\n    if (c_len > 4) {\n      utf16buf[out++] = 0xfffd;\n      i += c_len - 1;\n      continue;\n    } // apply mask on first byte\n\n\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07; // join the rest\n\n    while (c_len > 1 && i < len) {\n      c = c << 6 | buf[i++] & 0x3f;\n      c_len--;\n    } // terminated by end of string?\n\n\n    if (c_len > 1) {\n      utf16buf[out++] = 0xfffd;\n      continue;\n    }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff;\n      utf16buf[out++] = 0xdc00 | c & 0x3ff;\n    }\n  } // shrinkBuf(utf16buf, out)\n\n\n  if (utf16buf.length !== out) {\n    if (utf16buf.subarray) {\n      utf16buf = utf16buf.subarray(0, out);\n    } else {\n      utf16buf.length = out;\n    }\n  } // return String.fromCharCode.apply(null, utf16buf);\n\n\n  return utils.applyFromCharCode(utf16buf);\n}; // That's all for the pako functions.\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\n\n\nexports.utf8encode = function utf8encode(str) {\n  if (support.nodebuffer) {\n    return nodeBuffer(str, \"utf-8\");\n  }\n\n  return string2buf(str);\n};\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\n\n\nexports.utf8decode = function utf8decode(buf) {\n  if (support.nodebuffer) {\n    return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n  }\n\n  buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf); // return buf2string(buf);\n  // Chrome prefers to work with \"small\" chunks of data\n  // for the method buf2string.\n  // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.\n\n  var result = [],\n      k = 0,\n      len = buf.length,\n      chunk = 65536;\n\n  while (k < len) {\n    var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n\n    if (support.uint8array) {\n      result.push(buf2string(buf.subarray(k, nextBoundary)));\n    } else {\n      result.push(buf2string(buf.slice(k, nextBoundary)));\n    }\n\n    k = nextBoundary;\n  }\n\n  return result.join(\"\");\n}; // vim: set shiftwidth=4 softtabstop=4:","map":{"version":3,"sources":["/Users/maartenvanmeeuwen/Documents/stream-productie/stream-frontend/node_modules/jszip/lib/utf8.js"],"names":["utils","require","support","nodeBuffer","_utf8len","Array","i","string2buf","str","buf","c","c2","m_pos","str_len","length","buf_len","charCodeAt","uint8array","Uint8Array","utf8border","max","pos","buf2string","out","c_len","len","utf16buf","subarray","applyFromCharCode","exports","utf8encode","nodebuffer","utf8decode","transformTo","toString","result","k","chunk","nextBoundary","Math","min","push","slice","join"],"mappings":"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","sourcesContent":["'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodeBuffer = require('./nodeBuffer');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodeBuffer(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    // return buf2string(buf);\n    // Chrome prefers to work with \"small\" chunks of data\n    // for the method buf2string.\n    // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.\n    var result = [], k = 0, len = buf.length, chunk = 65536;\n    while (k < len) {\n        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n        if (support.uint8array) {\n            result.push(buf2string(buf.subarray(k, nextBoundary)));\n        } else {\n            result.push(buf2string(buf.slice(k, nextBoundary)));\n        }\n        k = nextBoundary;\n    }\n    return result.join(\"\");\n\n};\n// vim: set shiftwidth=4 softtabstop=4:\n"]},"metadata":{},"sourceType":"script"}