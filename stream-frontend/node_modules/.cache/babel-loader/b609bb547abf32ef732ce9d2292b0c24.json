{"ast":null,"code":"import _regeneratorRuntime from \"/Users/maartenvanmeeuwen/Documents/stream-productie/stream-frontend/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/maartenvanmeeuwen/Documents/stream-productie/stream-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\n\nfunction openDB(name, version) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      blocked = _ref.blocked,\n      upgrade = _ref.upgrade,\n      blocking = _ref.blocking;\n\n  var request = indexedDB.open(name, version);\n  var openPromise = wrap(request);\n\n  if (upgrade) {\n    request.addEventListener('upgradeneeded', function (event) {\n      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n    });\n  }\n\n  if (blocked) request.addEventListener('blocked', function () {\n    return blocked();\n  });\n  if (blocking) openPromise.then(function (db) {\n    return db.addEventListener('versionchange', blocking);\n  });\n  return openPromise;\n}\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\n\n\nfunction deleteDB(name) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      blocked = _ref2.blocked;\n\n  var request = indexedDB.deleteDatabase(name);\n  if (blocked) request.addEventListener('blocked', function () {\n    return blocked();\n  });\n  return wrap(request).then(function () {\n    return undefined;\n  });\n}\n\nvar readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nvar writeMethods = ['put', 'add', 'delete', 'clear'];\nvar cachedMethods = new Map();\n\nfunction getMethod(target, prop) {\n  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) return;\n  if (cachedMethods.get(prop)) return cachedMethods.get(prop);\n  var targetFuncName = prop.replace(/FromIndex$/, '');\n  var useIndex = prop !== targetFuncName;\n  var isWrite = writeMethods.includes(targetFuncName);\n  if ( // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n  !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) return;\n\n  var method = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(storeName) {\n      var _target;\n\n      var tx,\n          target,\n          _len,\n          args,\n          _key,\n          returnVal,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n              tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n              target = tx.store;\n\n              for (_len = _args.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = _args[_key];\n              }\n\n              if (useIndex) target = target.index(args.shift());\n              returnVal = (_target = target)[targetFuncName].apply(_target, args);\n\n              if (!isWrite) {\n                _context.next = 8;\n                break;\n              }\n\n              _context.next = 8;\n              return tx.done;\n\n            case 8:\n              return _context.abrupt(\"return\", returnVal);\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function method(_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  cachedMethods.set(prop, method);\n  return method;\n}\n\naddTraps(function (oldTraps) {\n  return {\n    get: function get(target, prop, receiver) {\n      return getMethod(target, prop) || oldTraps.get(target, prop, receiver);\n    },\n    has: function has(target, prop) {\n      return !!getMethod(target, prop) || oldTraps.has(target, prop);\n    }\n  };\n});\nexport { openDB, deleteDB };","map":{"version":3,"sources":["/Users/maartenvanmeeuwen/Documents/stream-productie/stream-frontend/node_modules/idb/build/esm/index.js"],"names":["a","wrap","b","addTraps","e","unwrap","openDB","name","version","blocked","upgrade","blocking","request","indexedDB","open","openPromise","addEventListener","event","result","oldVersion","newVersion","transaction","then","db","deleteDB","deleteDatabase","undefined","readMethods","writeMethods","cachedMethods","Map","getMethod","target","prop","IDBDatabase","get","targetFuncName","replace","useIndex","isWrite","includes","IDBIndex","IDBObjectStore","prototype","method","storeName","tx","store","args","index","shift","returnVal","done","set","oldTraps","receiver","has"],"mappings":"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","sourcesContent":["import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking)\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking));\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string'))\r\n        return;\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName)))\r\n        return;\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n"]},"metadata":{},"sourceType":"module"}