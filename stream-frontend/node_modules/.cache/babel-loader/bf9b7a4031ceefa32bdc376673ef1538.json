{"ast":null,"code":"'use strict';\n\nvar support = require('./support');\n\nvar utils = require('./utils');\n\nvar _crc = require('./crc32');\n\nvar signature = require('./signature');\n\nvar defaults = require('./defaults');\n\nvar base64 = require('./base64');\n\nvar compressions = require('./compressions');\n\nvar CompressedObject = require('./compressedObject');\n\nvar nodeBuffer = require('./nodeBuffer');\n\nvar utf8 = require('./utf8');\n\nvar StringWriter = require('./stringWriter');\n\nvar Uint8ArrayWriter = require('./uint8ArrayWriter');\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\n\n\nvar getRawData = function getRawData(file) {\n  if (file._data instanceof CompressedObject) {\n    file._data = file._data.getContent();\n    file.options.binary = true;\n    file.options.base64 = false;\n\n    if (utils.getTypeOf(file._data) === \"uint8array\") {\n      var copy = file._data; // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n      // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n\n      file._data = new Uint8Array(copy.length); // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n\n      if (copy.length !== 0) {\n        file._data.set(copy, 0);\n      }\n    }\n  }\n\n  return file._data;\n};\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\n\n\nvar getBinaryData = function getBinaryData(file) {\n  var result = getRawData(file),\n      type = utils.getTypeOf(result);\n\n  if (type === \"string\") {\n    if (!file.options.binary) {\n      // unicode text !\n      // unicode string => binary string is a painful process, check if we can avoid it.\n      if (support.nodebuffer) {\n        return nodeBuffer(result, \"utf-8\");\n      }\n    }\n\n    return file.asBinary();\n  }\n\n  return result;\n};\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\n\n\nvar dataToString = function dataToString(asUTF8) {\n  var result = getRawData(this);\n\n  if (result === null || typeof result === \"undefined\") {\n    return \"\";\n  } // if the data is a base64 string, we decode it before checking the encoding !\n\n\n  if (this.options.base64) {\n    result = base64.decode(result);\n  }\n\n  if (asUTF8 && this.options.binary) {\n    // JSZip.prototype.utf8decode supports arrays as input\n    // skip to array => string step, utf8decode will do it.\n    result = out.utf8decode(result);\n  } else {\n    // no utf8 transformation, do the array => string step.\n    result = utils.transformTo(\"string\", result);\n  }\n\n  if (!asUTF8 && !this.options.binary) {\n    result = utils.transformTo(\"string\", out.utf8encode(result));\n  }\n\n  return result;\n};\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\n\n\nvar ZipObject = function ZipObject(name, data, options) {\n  this.name = name;\n  this.dir = options.dir;\n  this.date = options.date;\n  this.comment = options.comment;\n  this._data = data;\n  this.options = options;\n  /*\n   * This object contains initial values for dir and date.\n   * With them, we can check if the user changed the deprecated metadata in\n   * `ZipObject#options` or not.\n   */\n\n  this._initialMetadata = {\n    dir: options.dir,\n    date: options.date\n  };\n};\n\nZipObject.prototype = {\n  /**\n   * Return the content as UTF8 string.\n   * @return {string} the UTF8 string.\n   */\n  asText: function asText() {\n    return dataToString.call(this, true);\n  },\n\n  /**\n   * Returns the binary content.\n   * @return {string} the content as binary.\n   */\n  asBinary: function asBinary() {\n    return dataToString.call(this, false);\n  },\n\n  /**\n   * Returns the content as a nodejs Buffer.\n   * @return {Buffer} the content as a Buffer.\n   */\n  asNodeBuffer: function asNodeBuffer() {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"nodebuffer\", result);\n  },\n\n  /**\n   * Returns the content as an Uint8Array.\n   * @return {Uint8Array} the content as an Uint8Array.\n   */\n  asUint8Array: function asUint8Array() {\n    var result = getBinaryData(this);\n    return utils.transformTo(\"uint8array\", result);\n  },\n\n  /**\n   * Returns the content as an ArrayBuffer.\n   * @return {ArrayBuffer} the content as an ArrayBufer.\n   */\n  asArrayBuffer: function asArrayBuffer() {\n    return this.asUint8Array().buffer;\n  }\n};\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\n\nvar decToHex = function decToHex(dec, bytes) {\n  var hex = \"\",\n      i;\n\n  for (i = 0; i < bytes; i++) {\n    hex += String.fromCharCode(dec & 0xff);\n    dec = dec >>> 8;\n  }\n\n  return hex;\n};\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\n\n\nvar extend = function extend() {\n  var result = {},\n      i,\n      attr;\n\n  for (i = 0; i < arguments.length; i++) {\n    // arguments is not enumerable in some browsers\n    for (attr in arguments[i]) {\n      if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n        result[attr] = arguments[i][attr];\n      }\n    }\n  }\n\n  return result;\n};\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\n\n\nvar prepareFileAttrs = function prepareFileAttrs(o) {\n  o = o || {};\n\n  if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n    o.binary = true;\n  }\n\n  o = extend(o, defaults);\n  o.date = o.date || new Date();\n  if (o.compression !== null) o.compression = o.compression.toUpperCase();\n  return o;\n};\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\n\n\nvar fileAdd = function fileAdd(name, data, o) {\n  // be sure sub folders exist\n  var dataType = utils.getTypeOf(data),\n      parent;\n  o = prepareFileAttrs(o);\n\n  if (o.createFolders && (parent = parentFolder(name))) {\n    folderAdd.call(this, parent, true);\n  }\n\n  if (o.dir || data === null || typeof data === \"undefined\") {\n    o.base64 = false;\n    o.binary = false;\n    data = null;\n  } else if (dataType === \"string\") {\n    if (o.binary && !o.base64) {\n      // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n      if (o.optimizedBinaryString !== true) {\n        // this is a string, not in a base64 format.\n        // Be sure that this is a correct \"binary string\"\n        data = utils.string2binary(data);\n      }\n    }\n  } else {\n    // arraybuffer, uint8array, ...\n    o.base64 = false;\n    o.binary = true;\n\n    if (!dataType && !(data instanceof CompressedObject)) {\n      throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n    } // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n\n\n    if (dataType === \"arraybuffer\") {\n      data = utils.transformTo(\"uint8array\", data);\n    }\n  }\n\n  var object = new ZipObject(name, data, o);\n  this.files[name] = object;\n  return object;\n};\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\n\n\nvar parentFolder = function parentFolder(path) {\n  if (path.slice(-1) == '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  var lastSlash = path.lastIndexOf('/');\n  return lastSlash > 0 ? path.substring(0, lastSlash) : \"\";\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub \n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\n\n\nvar folderAdd = function folderAdd(name, createFolders) {\n  // Check the name ends with a /\n  if (name.slice(-1) != \"/\") {\n    name += \"/\"; // IE doesn't like substr(-1)\n  }\n\n  createFolders = typeof createFolders !== 'undefined' ? createFolders : false; // Does this folder already exist?\n\n  if (!this.files[name]) {\n    fileAdd.call(this, name, null, {\n      dir: true,\n      createFolders: createFolders\n    });\n  }\n\n  return this.files[name];\n};\n/**\n * Generate a JSZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {JSZip.compression} compression the compression to use.\n * @return {JSZip.CompressedObject} the compressed result.\n */\n\n\nvar generateCompressedObjectFrom = function generateCompressedObjectFrom(file, compression) {\n  var result = new CompressedObject(),\n      content; // the data has not been decompressed, we might reuse things !\n\n  if (file._data instanceof CompressedObject) {\n    result.uncompressedSize = file._data.uncompressedSize;\n    result.crc32 = file._data.crc32;\n\n    if (result.uncompressedSize === 0 || file.dir) {\n      compression = compressions['STORE'];\n      result.compressedContent = \"\";\n      result.crc32 = 0;\n    } else if (file._data.compressionMethod === compression.magic) {\n      result.compressedContent = file._data.getCompressedContent();\n    } else {\n      content = file._data.getContent(); // need to decompress / recompress\n\n      result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content));\n    }\n  } else {\n    // have uncompressed data\n    content = getBinaryData(file);\n\n    if (!content || content.length === 0 || file.dir) {\n      compression = compressions['STORE'];\n      content = \"\";\n    }\n\n    result.uncompressedSize = content.length;\n    result.crc32 = _crc(content);\n    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content));\n  }\n\n  result.compressedSize = result.compressedContent.length;\n  result.compressionMethod = compression.magic;\n  return result;\n};\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {JSZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @return {object} the zip parts.\n */\n\n\nvar generateZipParts = function generateZipParts(name, file, compressedObject, offset) {\n  var data = compressedObject.compressedContent,\n      utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n      comment = file.comment || \"\",\n      utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n      useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n      useUTF8ForComment = utfEncodedComment.length !== comment.length,\n      o = file.options,\n      dosTime,\n      dosDate,\n      extraFields = \"\",\n      unicodePathExtraField = \"\",\n      unicodeCommentExtraField = \"\",\n      dir,\n      date; // handle the deprecated options.dir\n\n  if (file._initialMetadata.dir !== file.dir) {\n    dir = file.dir;\n  } else {\n    dir = o.dir;\n  } // handle the deprecated options.date\n\n\n  if (file._initialMetadata.date !== file.date) {\n    date = file.date;\n  } else {\n    date = o.date;\n  } // date\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n  // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n\n  dosTime = date.getHours();\n  dosTime = dosTime << 6;\n  dosTime = dosTime | date.getMinutes();\n  dosTime = dosTime << 5;\n  dosTime = dosTime | date.getSeconds() / 2;\n  dosDate = date.getFullYear() - 1980;\n  dosDate = dosDate << 4;\n  dosDate = dosDate | date.getMonth() + 1;\n  dosDate = dosDate << 5;\n  dosDate = dosDate | date.getDate();\n\n  if (useUTF8ForFileName) {\n    // set the unicode path extra field. unzip needs at least one extra\n    // field to correctly handle unicode path, so using the path is as good\n    // as any other information. This could improve the situation with\n    // other archive managers too.\n    // This field is usually used without the utf8 flag, with a non\n    // unicode path in the header (winrar, winzip). This helps (a bit)\n    // with the messy Windows' default compressed folders feature but\n    // breaks on p7zip which doesn't seek the unicode path extra field.\n    // So for now, UTF-8 everywhere !\n    unicodePathExtraField = // Version\n    decToHex(1, 1) + // NameCRC32\n    decToHex(_crc(utfEncodedFileName), 4) + // UnicodeName\n    utfEncodedFileName;\n    extraFields += // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x70\" + // size\n    decToHex(unicodePathExtraField.length, 2) + // content\n    unicodePathExtraField;\n  }\n\n  if (useUTF8ForComment) {\n    unicodeCommentExtraField = // Version\n    decToHex(1, 1) + // CommentCRC32\n    decToHex(this.crc32(utfEncodedComment), 4) + // UnicodeName\n    utfEncodedComment;\n    extraFields += // Info-ZIP Unicode Path Extra Field\n    \"\\x75\\x63\" + // size\n    decToHex(unicodeCommentExtraField.length, 2) + // content\n    unicodeCommentExtraField;\n  }\n\n  var header = \"\"; // version needed to extract\n\n  header += \"\\x0A\\x00\"; // general purpose bit flag\n  // set bit 11 if utf8\n\n  header += useUTF8ForFileName || useUTF8ForComment ? \"\\x00\\x08\" : \"\\x00\\x00\"; // compression method\n\n  header += compressedObject.compressionMethod; // last mod file time\n\n  header += decToHex(dosTime, 2); // last mod file date\n\n  header += decToHex(dosDate, 2); // crc-32\n\n  header += decToHex(compressedObject.crc32, 4); // compressed size\n\n  header += decToHex(compressedObject.compressedSize, 4); // uncompressed size\n\n  header += decToHex(compressedObject.uncompressedSize, 4); // file name length\n\n  header += decToHex(utfEncodedFileName.length, 2); // extra field length\n\n  header += decToHex(extraFields.length, 2);\n  var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;\n  var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)\n  \"\\x14\\x00\" + // file header (common to file and central directory)\n  header + // file comment length\n  decToHex(utfEncodedComment.length, 2) + // disk number start\n  \"\\x00\\x00\" + // internal file attributes TODO\n  \"\\x00\\x00\" + ( // external file attributes\n  dir === true ? \"\\x10\\x00\\x00\\x00\" : \"\\x00\\x00\\x00\\x00\") + // relative offset of local header\n  decToHex(offset, 4) + // file name\n  utfEncodedFileName + // extra field\n  extraFields + // file comment\n  utfEncodedComment;\n  return {\n    fileRecord: fileRecord,\n    dirRecord: dirRecord,\n    compressedObject: compressedObject\n  };\n}; // return the actual prototype of JSZip\n\n\nvar out = {\n  /**\n   * Read an existing zip and merge the data in the current JSZip object.\n   * The implementation is in jszip-load.js, don't forget to include it.\n   * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n   * @param {Object} options Options for loading the stream.\n   *  options.base64 : is the stream in base64 ? default : false\n   * @return {JSZip} the current JSZip object\n   */\n  load: function load(stream, options) {\n    throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n  },\n\n  /**\n   * Filter nested files/folders with the specified function.\n   * @param {Function} search the predicate to use :\n   * function (relativePath, file) {...}\n   * It takes 2 arguments : the relative path and the file.\n   * @return {Array} An array of matching elements.\n   */\n  filter: function filter(search) {\n    var result = [],\n        filename,\n        relativePath,\n        file,\n        fileClone;\n\n    for (filename in this.files) {\n      if (!this.files.hasOwnProperty(filename)) {\n        continue;\n      }\n\n      file = this.files[filename]; // return a new object, don't let the user mess with our internal objects :)\n\n      fileClone = new ZipObject(file.name, file._data, extend(file.options));\n      relativePath = filename.slice(this.root.length, filename.length);\n\n      if (filename.slice(0, this.root.length) === this.root && // the file is in the current root\n      search(relativePath, fileClone)) {\n        // and the file matches the function\n        result.push(fileClone);\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Add a file to the zip file, or search a file.\n   * @param   {string|RegExp} name The name of the file to add (if data is defined),\n   * the name of the file to find (if no data) or a regex to match files.\n   * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n   * @param   {Object} o     File options\n   * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n   * a file (when searching by string) or an array of files (when searching by regex).\n   */\n  file: function file(name, data, o) {\n    if (arguments.length === 1) {\n      if (utils.isRegExp(name)) {\n        var regexp = name;\n        return this.filter(function (relativePath, file) {\n          return !file.dir && regexp.test(relativePath);\n        });\n      } else {\n        // text\n        return this.filter(function (relativePath, file) {\n          return !file.dir && relativePath === name;\n        })[0] || null;\n      }\n    } else {\n      // more than one argument : we have data !\n      name = this.root + name;\n      fileAdd.call(this, name, data, o);\n    }\n\n    return this;\n  },\n\n  /**\n   * Add a directory to the zip file, or search.\n   * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n   * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n   */\n  folder: function folder(arg) {\n    if (!arg) {\n      return this;\n    }\n\n    if (utils.isRegExp(arg)) {\n      return this.filter(function (relativePath, file) {\n        return file.dir && arg.test(relativePath);\n      });\n    } // else, name is a new folder\n\n\n    var name = this.root + arg;\n    var newFolder = folderAdd.call(this, name); // Allow chaining by returning a new object with this folder as the root\n\n    var ret = this.clone();\n    ret.root = newFolder.name;\n    return ret;\n  },\n\n  /**\n   * Delete a file, or a directory and all sub-files, from the zip\n   * @param {string} name the name of the file to delete\n   * @return {JSZip} this JSZip object\n   */\n  remove: function remove(name) {\n    name = this.root + name;\n    var file = this.files[name];\n\n    if (!file) {\n      // Look for any folders\n      if (name.slice(-1) != \"/\") {\n        name += \"/\";\n      }\n\n      file = this.files[name];\n    }\n\n    if (file && !file.dir) {\n      // file\n      delete this.files[name];\n    } else {\n      // maybe a folder, delete recursively\n      var kids = this.filter(function (relativePath, file) {\n        return file.name.slice(0, name.length) === name;\n      });\n\n      for (var i = 0; i < kids.length; i++) {\n        delete this.files[kids[i].name];\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Generate the complete zip file\n   * @param {Object} options the options to generate the zip file :\n   * - base64, (deprecated, use type instead) true to generate base64.\n   * - compression, \"STORE\" by default.\n   * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n   * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n   */\n  generate: function generate(options) {\n    options = extend(options || {}, {\n      base64: true,\n      compression: \"STORE\",\n      type: \"base64\",\n      comment: null\n    });\n    utils.checkSupport(options.type);\n    var zipData = [],\n        localDirLength = 0,\n        centralDirLength = 0,\n        writer,\n        i,\n        utfEncodedComment = utils.transformTo(\"string\", this.utf8encode(options.comment || this.comment || \"\")); // first, generate all the zip parts.\n\n    for (var name in this.files) {\n      if (!this.files.hasOwnProperty(name)) {\n        continue;\n      }\n\n      var file = this.files[name];\n      var compressionName = file.options.compression || options.compression.toUpperCase();\n      var compression = compressions[compressionName];\n\n      if (!compression) {\n        throw new Error(compressionName + \" is not a valid compression method !\");\n      }\n\n      var compressedObject = generateCompressedObjectFrom.call(this, file, compression);\n      var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength);\n      localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n      centralDirLength += zipPart.dirRecord.length;\n      zipData.push(zipPart);\n    }\n\n    var dirEnd = \"\"; // end of central dir signature\n\n    dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk\n    \"\\x00\\x00\" + // number of the disk with the start of the central directory\n    \"\\x00\\x00\" + // total number of entries in the central directory on this disk\n    decToHex(zipData.length, 2) + // total number of entries in the central directory\n    decToHex(zipData.length, 2) + // size of the central directory   4 bytes\n    decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number\n    decToHex(localDirLength, 4) + // .ZIP file comment length\n    decToHex(utfEncodedComment.length, 2) + // .ZIP file comment\n    utfEncodedComment; // we have all the parts (and the total length)\n    // time to create a writer !\n\n    var typeName = options.type.toLowerCase();\n\n    if (typeName === \"uint8array\" || typeName === \"arraybuffer\" || typeName === \"blob\" || typeName === \"nodebuffer\") {\n      writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n    } else {\n      writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n    }\n\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].fileRecord);\n      writer.append(zipData[i].compressedObject.compressedContent);\n    }\n\n    for (i = 0; i < zipData.length; i++) {\n      writer.append(zipData[i].dirRecord);\n    }\n\n    writer.append(dirEnd);\n    var zip = writer.finalize();\n\n    switch (options.type.toLowerCase()) {\n      // case \"zip is an Uint8Array\"\n      case \"uint8array\":\n      case \"arraybuffer\":\n      case \"nodebuffer\":\n        return utils.transformTo(options.type.toLowerCase(), zip);\n\n      case \"blob\":\n        return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip));\n      // case \"zip is a string\"\n\n      case \"base64\":\n        return options.base64 ? base64.encode(zip) : zip;\n\n      default:\n        // case \"string\" :\n        return zip;\n    }\n  },\n\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  crc32: function crc32(input, crc) {\n    return _crc(input, crc);\n  },\n\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8encode: function utf8encode(string) {\n    return utils.transformTo(\"string\", utf8.utf8encode(string));\n  },\n\n  /**\n   * @deprecated\n   * This method will be removed in a future version without replacement.\n   */\n  utf8decode: function utf8decode(input) {\n    return utf8.utf8decode(input);\n  }\n};\nmodule.exports = out;","map":{"version":3,"sources":["/Users/maartenvanmeeuwen/Documents/stream-productie/stream-frontend/node_modules/jszip/lib/object.js"],"names":["support","require","utils","crc32","signature","defaults","base64","compressions","CompressedObject","nodeBuffer","utf8","StringWriter","Uint8ArrayWriter","getRawData","file","_data","getContent","options","binary","getTypeOf","copy","Uint8Array","length","set","getBinaryData","result","type","nodebuffer","asBinary","dataToString","asUTF8","decode","out","utf8decode","transformTo","utf8encode","ZipObject","name","data","dir","date","comment","_initialMetadata","prototype","asText","call","asNodeBuffer","asUint8Array","asArrayBuffer","buffer","decToHex","dec","bytes","hex","i","String","fromCharCode","extend","attr","arguments","hasOwnProperty","prepareFileAttrs","o","undefined","Date","compression","toUpperCase","fileAdd","dataType","parent","createFolders","parentFolder","folderAdd","optimizedBinaryString","string2binary","Error","object","files","path","slice","substring","lastSlash","lastIndexOf","generateCompressedObjectFrom","content","uncompressedSize","compressedContent","compressionMethod","magic","getCompressedContent","compress","compressInputType","compressedSize","generateZipParts","compressedObject","offset","utfEncodedFileName","utfEncodedComment","useUTF8ForFileName","useUTF8ForComment","dosTime","dosDate","extraFields","unicodePathExtraField","unicodeCommentExtraField","getHours","getMinutes","getSeconds","getFullYear","getMonth","getDate","header","fileRecord","LOCAL_FILE_HEADER","dirRecord","CENTRAL_FILE_HEADER","load","stream","filter","search","filename","relativePath","fileClone","root","push","isRegExp","regexp","test","folder","arg","newFolder","ret","clone","remove","kids","generate","checkSupport","zipData","localDirLength","centralDirLength","writer","compressionName","zipPart","dirEnd","CENTRAL_DIRECTORY_END","typeName","toLowerCase","append","zip","finalize","arrayBuffer2Blob","encode","input","crc","string","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nvar support = require('./support');\nvar utils = require('./utils');\nvar crc32 = require('./crc32');\nvar signature = require('./signature');\nvar defaults = require('./defaults');\nvar base64 = require('./base64');\nvar compressions = require('./compressions');\nvar CompressedObject = require('./compressedObject');\nvar nodeBuffer = require('./nodeBuffer');\nvar utf8 = require('./utf8');\nvar StringWriter = require('./stringWriter');\nvar Uint8ArrayWriter = require('./uint8ArrayWriter');\n\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getRawData = function(file) {\n    if (file._data instanceof CompressedObject) {\n        file._data = file._data.getContent();\n        file.options.binary = true;\n        file.options.base64 = false;\n\n        if (utils.getTypeOf(file._data) === \"uint8array\") {\n            var copy = file._data;\n            // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n            // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n            file._data = new Uint8Array(copy.length);\n            // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n            if (copy.length !== 0) {\n                file._data.set(copy, 0);\n            }\n        }\n    }\n    return file._data;\n};\n\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getBinaryData = function(file) {\n    var result = getRawData(file),\n        type = utils.getTypeOf(result);\n    if (type === \"string\") {\n        if (!file.options.binary) {\n            // unicode text !\n            // unicode string => binary string is a painful process, check if we can avoid it.\n            if (support.nodebuffer) {\n                return nodeBuffer(result, \"utf-8\");\n            }\n        }\n        return file.asBinary();\n    }\n    return result;\n};\n\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\nvar dataToString = function(asUTF8) {\n    var result = getRawData(this);\n    if (result === null || typeof result === \"undefined\") {\n        return \"\";\n    }\n    // if the data is a base64 string, we decode it before checking the encoding !\n    if (this.options.base64) {\n        result = base64.decode(result);\n    }\n    if (asUTF8 && this.options.binary) {\n        // JSZip.prototype.utf8decode supports arrays as input\n        // skip to array => string step, utf8decode will do it.\n        result = out.utf8decode(result);\n    }\n    else {\n        // no utf8 transformation, do the array => string step.\n        result = utils.transformTo(\"string\", result);\n    }\n\n    if (!asUTF8 && !this.options.binary) {\n        result = utils.transformTo(\"string\", out.utf8encode(result));\n    }\n    return result;\n};\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n\n    this._data = data;\n    this.options = options;\n\n    /*\n     * This object contains initial values for dir and date.\n     * With them, we can check if the user changed the deprecated metadata in\n     * `ZipObject#options` or not.\n     */\n    this._initialMetadata = {\n      dir : options.dir,\n      date : options.date\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Return the content as UTF8 string.\n     * @return {string} the UTF8 string.\n     */\n    asText: function() {\n        return dataToString.call(this, true);\n    },\n    /**\n     * Returns the binary content.\n     * @return {string} the content as binary.\n     */\n    asBinary: function() {\n        return dataToString.call(this, false);\n    },\n    /**\n     * Returns the content as a nodejs Buffer.\n     * @return {Buffer} the content as a Buffer.\n     */\n    asNodeBuffer: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"nodebuffer\", result);\n    },\n    /**\n     * Returns the content as an Uint8Array.\n     * @return {Uint8Array} the content as an Uint8Array.\n     */\n    asUint8Array: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"uint8array\", result);\n    },\n    /**\n     * Returns the content as an ArrayBuffer.\n     * @return {ArrayBuffer} the content as an ArrayBufer.\n     */\n    asArrayBuffer: function() {\n        return this.asUint8Array().buffer;\n    }\n};\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\",\n        i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nvar extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\nvar prepareFileAttrs = function(o) {\n    o = o || {};\n    if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n        o.binary = true;\n    }\n    o = extend(o, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) o.compression = o.compression.toUpperCase();\n\n    return o;\n};\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, o) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n    o = prepareFileAttrs(o);\n\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    if (o.dir || data === null || typeof data === \"undefined\") {\n        o.base64 = false;\n        o.binary = false;\n        data = null;\n    }\n    else if (dataType === \"string\") {\n        if (o.binary && !o.base64) {\n            // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n            if (o.optimizedBinaryString !== true) {\n                // this is a string, not in a base64 format.\n                // Be sure that this is a correct \"binary string\"\n                data = utils.string2binary(data);\n            }\n        }\n    }\n    else { // arraybuffer, uint8array, ...\n        o.base64 = false;\n        o.binary = true;\n\n        if (!dataType && !(data instanceof CompressedObject)) {\n            throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n        }\n\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = utils.transformTo(\"uint8array\", data);\n        }\n    }\n\n    var object = new ZipObject(name, data, o);\n    this.files[name] = object;\n    return object;\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) == '/') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf('/');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n};\n\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub \n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    // Check the name ends with a /\n    if (name.slice(-1) != \"/\") {\n        name += \"/\"; // IE doesn't like substr(-1)\n    }\n\n    createFolders = (typeof createFolders !== 'undefined') ? createFolders : false;\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n * Generate a JSZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {JSZip.compression} compression the compression to use.\n * @return {JSZip.CompressedObject} the compressed result.\n */\nvar generateCompressedObjectFrom = function(file, compression) {\n    var result = new CompressedObject(),\n        content;\n\n    // the data has not been decompressed, we might reuse things !\n    if (file._data instanceof CompressedObject) {\n        result.uncompressedSize = file._data.uncompressedSize;\n        result.crc32 = file._data.crc32;\n\n        if (result.uncompressedSize === 0 || file.dir) {\n            compression = compressions['STORE'];\n            result.compressedContent = \"\";\n            result.crc32 = 0;\n        }\n        else if (file._data.compressionMethod === compression.magic) {\n            result.compressedContent = file._data.getCompressedContent();\n        }\n        else {\n            content = file._data.getContent();\n            // need to decompress / recompress\n            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content));\n        }\n    }\n    else {\n        // have uncompressed data\n        content = getBinaryData(file);\n        if (!content || content.length === 0 || file.dir) {\n            compression = compressions['STORE'];\n            content = \"\";\n        }\n        result.uncompressedSize = content.length;\n        result.crc32 = crc32(content);\n        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content));\n    }\n\n    result.compressedSize = result.compressedContent.length;\n    result.compressionMethod = compression.magic;\n\n    return result;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {JSZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @return {object} the zip parts.\n */\nvar generateZipParts = function(name, file, compressedObject, offset) {\n    var data = compressedObject.compressedContent,\n        utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n        comment = file.comment || \"\",\n        utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n        useUTF8ForComment = utfEncodedComment.length !== comment.length,\n        o = file.options,\n        dosTime,\n        dosDate,\n        extraFields = \"\",\n        unicodePathExtraField = \"\",\n        unicodeCommentExtraField = \"\",\n        dir, date;\n\n\n    // handle the deprecated options.dir\n    if (file._initialMetadata.dir !== file.dir) {\n        dir = file.dir;\n    } else {\n        dir = o.dir;\n    }\n\n    // handle the deprecated options.date\n    if(file._initialMetadata.date !== file.date) {\n        date = file.date;\n    } else {\n        date = o.date;\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getSeconds() / 2;\n\n    dosDate = date.getFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(utfEncodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(this.crc32(utfEncodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    // set bit 11 if utf8\n    header += (useUTF8ForFileName || useUTF8ForComment) ? \"\\x00\\x08\" : \"\\x00\\x00\";\n    // compression method\n    header += compressedObject.compressionMethod;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(compressedObject.crc32, 4);\n    // compressed size\n    header += decToHex(compressedObject.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(compressedObject.uncompressedSize, 4);\n    // file name length\n    header += decToHex(utfEncodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n    // version made by (00: DOS)\n    \"\\x14\\x00\" +\n    // file header (common to file and central directory)\n    header +\n    // file comment length\n    decToHex(utfEncodedComment.length, 2) +\n    // disk number start\n    \"\\x00\\x00\" +\n    // internal file attributes TODO\n    \"\\x00\\x00\" +\n    // external file attributes\n    (dir === true ? \"\\x10\\x00\\x00\\x00\" : \"\\x00\\x00\\x00\\x00\") +\n    // relative offset of local header\n    decToHex(offset, 4) +\n    // file name\n    utfEncodedFileName +\n    // extra field\n    extraFields +\n    // file comment\n    utfEncodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord,\n        compressedObject: compressedObject\n    };\n};\n\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * Read an existing zip and merge the data in the current JSZip object.\n     * The implementation is in jszip-load.js, don't forget to include it.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n     * @param {Object} options Options for loading the stream.\n     *  options.base64 : is the stream in base64 ? default : false\n     * @return {JSZip} the current JSZip object\n     */\n    load: function(stream, options) {\n        throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [],\n            filename, relativePath, file, fileClone;\n        for (filename in this.files) {\n            if (!this.files.hasOwnProperty(filename)) {\n                continue;\n            }\n            file = this.files[filename];\n            // return a new object, don't let the user mess with our internal objects :)\n            fileClone = new ZipObject(file.name, file._data, extend(file.options));\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (filename.slice(0, this.root.length) === this.root && // the file is in the current root\n            search(relativePath, fileClone)) { // and the file matches the function\n                result.push(fileClone);\n            }\n        }\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (utils.isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && relativePath === name;\n                })[0] || null;\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (utils.isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) != \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - base64, (deprecated, use type instead) true to generate base64.\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        options = extend(options || {}, {\n            base64: true,\n            compression: \"STORE\",\n            type: \"base64\",\n            comment: null\n        });\n\n        utils.checkSupport(options.type);\n\n        var zipData = [],\n            localDirLength = 0,\n            centralDirLength = 0,\n            writer, i,\n            utfEncodedComment = utils.transformTo(\"string\", this.utf8encode(options.comment || this.comment || \"\"));\n\n        // first, generate all the zip parts.\n        for (var name in this.files) {\n            if (!this.files.hasOwnProperty(name)) {\n                continue;\n            }\n            var file = this.files[name];\n\n            var compressionName = file.options.compression || options.compression.toUpperCase();\n            var compression = compressions[compressionName];\n            if (!compression) {\n                throw new Error(compressionName + \" is not a valid compression method !\");\n            }\n\n            var compressedObject = generateCompressedObjectFrom.call(this, file, compression);\n\n            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength);\n            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n            centralDirLength += zipPart.dirRecord.length;\n            zipData.push(zipPart);\n        }\n\n        var dirEnd = \"\";\n\n        // end of central dir signature\n        dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(zipData.length, 2) +\n        // total number of entries in the central directory\n        decToHex(zipData.length, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(utfEncodedComment.length, 2) +\n        // .ZIP file comment\n        utfEncodedComment;\n\n\n        // we have all the parts (and the total length)\n        // time to create a writer !\n        var typeName = options.type.toLowerCase();\n        if(typeName===\"uint8array\"||typeName===\"arraybuffer\"||typeName===\"blob\"||typeName===\"nodebuffer\") {\n            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n        }else{\n            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n        }\n\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].fileRecord);\n            writer.append(zipData[i].compressedObject.compressedContent);\n        }\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].dirRecord);\n        }\n\n        writer.append(dirEnd);\n\n        var zip = writer.finalize();\n\n\n\n        switch(options.type.toLowerCase()) {\n            // case \"zip is an Uint8Array\"\n            case \"uint8array\" :\n            case \"arraybuffer\" :\n            case \"nodebuffer\" :\n               return utils.transformTo(options.type.toLowerCase(), zip);\n            case \"blob\" :\n               return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip));\n            // case \"zip is a string\"\n            case \"base64\" :\n               return (options.base64) ? base64.encode(zip) : zip;\n            default : // case \"string\" :\n               return zip;\n         }\n      \n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    crc32: function (input, crc) {\n        return crc32(input, crc);\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8encode: function (string) {\n        return utils.transformTo(\"string\", utf8.utf8encode(string));\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8decode: function (input) {\n        return utf8.utf8decode(input);\n    }\n};\nmodule.exports = out;\n"]},"metadata":{},"sourceType":"script"}