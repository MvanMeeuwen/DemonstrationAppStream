{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nfunction DataReader(data) {\n  this.data = null; // type : see implementation\n\n  this.length = 0;\n  this.index = 0;\n}\n\nDataReader.prototype = {\n  /**\n   * Check that the offset will not go too far.\n   * @param {string} offset the additional offset to check.\n   * @throws {Error} an Error if the offset is out of bounds.\n   */\n  checkOffset: function (offset) {\n    this.checkIndex(this.index + offset);\n  },\n\n  /**\n   * Check that the specifed index will not be too far.\n   * @param {string} newIndex the index to check.\n   * @throws {Error} an Error if the index is out of bounds.\n   */\n  checkIndex: function (newIndex) {\n    if (this.length < newIndex || newIndex < 0) {\n      throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n    }\n  },\n\n  /**\n   * Change the index.\n   * @param {number} newIndex The new index.\n   * @throws {Error} if the new index is out of the data.\n   */\n  setIndex: function (newIndex) {\n    this.checkIndex(newIndex);\n    this.index = newIndex;\n  },\n\n  /**\n   * Skip the next n bytes.\n   * @param {number} n the number of bytes to skip.\n   * @throws {Error} if the new index is out of the data.\n   */\n  skip: function (n) {\n    this.setIndex(this.index + n);\n  },\n\n  /**\n   * Get the byte at the specified index.\n   * @param {number} i the index to use.\n   * @return {number} a byte.\n   */\n  byteAt: function (i) {// see implementations\n  },\n\n  /**\n   * Get the next number with a given byte size.\n   * @param {number} size the number of bytes to read.\n   * @return {number} the corresponding number.\n   */\n  readInt: function (size) {\n    var result = 0,\n        i;\n    this.checkOffset(size);\n\n    for (i = this.index + size - 1; i >= this.index; i--) {\n      result = (result << 8) + this.byteAt(i);\n    }\n\n    this.index += size;\n    return result;\n  },\n\n  /**\n   * Get the next string with a given byte size.\n   * @param {number} size the number of bytes to read.\n   * @return {string} the corresponding string.\n   */\n  readString: function (size) {\n    return utils.transformTo(\"string\", this.readData(size));\n  },\n\n  /**\n   * Get raw data without conversion, <size> bytes.\n   * @param {number} size the number of bytes to read.\n   * @return {Object} the raw data, implementation specific.\n   */\n  readData: function (size) {// see implementations\n  },\n\n  /**\n   * Find the last occurence of a zip signature (4 bytes).\n   * @param {string} sig the signature to find.\n   * @return {number} the index of the last occurence, -1 if not found.\n   */\n  lastIndexOfSignature: function (sig) {// see implementations\n  },\n\n  /**\n   * Get the next date.\n   * @return {Date} the date.\n   */\n  readDate: function () {\n    var dostime = this.readInt(4);\n    return new Date((dostime >> 25 & 0x7f) + 1980, // year\n    (dostime >> 21 & 0x0f) - 1, // month\n    dostime >> 16 & 0x1f, // day\n    dostime >> 11 & 0x1f, // hour\n    dostime >> 5 & 0x3f, // minute\n    (dostime & 0x1f) << 1); // second\n  }\n};\nmodule.exports = DataReader;","map":{"version":3,"sources":["/Users/maartenvanmeeuwen/Documents/stream-productie/stream-frontend/node_modules/jszip/lib/dataReader.js"],"names":["utils","require","DataReader","data","length","index","prototype","checkOffset","offset","checkIndex","newIndex","Error","setIndex","skip","n","byteAt","i","readInt","size","result","readString","transformTo","readData","lastIndexOfSignature","sig","readDate","dostime","Date","module","exports"],"mappings":"AAAA;;AACA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AAEA,SAASC,UAAT,CAAoBC,IAApB,EAA0B;AACtB,OAAKA,IAAL,GAAY,IAAZ,CADsB,CACJ;;AAClB,OAAKC,MAAL,GAAc,CAAd;AACA,OAAKC,KAAL,GAAa,CAAb;AACH;;AACDH,UAAU,CAACI,SAAX,GAAuB;AACnB;;;;;AAKAC,EAAAA,WAAW,EAAE,UAASC,MAAT,EAAiB;AAC1B,SAAKC,UAAL,CAAgB,KAAKJ,KAAL,GAAaG,MAA7B;AACH,GARkB;;AASnB;;;;;AAKAC,EAAAA,UAAU,EAAE,UAASC,QAAT,EAAmB;AAC3B,QAAI,KAAKN,MAAL,GAAcM,QAAd,IAA0BA,QAAQ,GAAG,CAAzC,EAA4C;AACxC,YAAM,IAAIC,KAAJ,CAAU,wCAAwC,KAAKP,MAA7C,GAAsD,kBAAtD,GAA4EM,QAA5E,GAAwF,oBAAlG,CAAN;AACH;AACJ,GAlBkB;;AAmBnB;;;;;AAKAE,EAAAA,QAAQ,EAAE,UAASF,QAAT,EAAmB;AACzB,SAAKD,UAAL,CAAgBC,QAAhB;AACA,SAAKL,KAAL,GAAaK,QAAb;AACH,GA3BkB;;AA4BnB;;;;;AAKAG,EAAAA,IAAI,EAAE,UAASC,CAAT,EAAY;AACd,SAAKF,QAAL,CAAc,KAAKP,KAAL,GAAaS,CAA3B;AACH,GAnCkB;;AAoCnB;;;;;AAKAC,EAAAA,MAAM,EAAE,UAASC,CAAT,EAAY,CAChB;AACH,GA3CkB;;AA4CnB;;;;;AAKAC,EAAAA,OAAO,EAAE,UAASC,IAAT,EAAe;AACpB,QAAIC,MAAM,GAAG,CAAb;AAAA,QACIH,CADJ;AAEA,SAAKT,WAAL,CAAiBW,IAAjB;;AACA,SAAKF,CAAC,GAAG,KAAKX,KAAL,GAAaa,IAAb,GAAoB,CAA7B,EAAgCF,CAAC,IAAI,KAAKX,KAA1C,EAAiDW,CAAC,EAAlD,EAAsD;AAClDG,MAAAA,MAAM,GAAG,CAACA,MAAM,IAAI,CAAX,IAAgB,KAAKJ,MAAL,CAAYC,CAAZ,CAAzB;AACH;;AACD,SAAKX,KAAL,IAAca,IAAd;AACA,WAAOC,MAAP;AACH,GA1DkB;;AA2DnB;;;;;AAKAC,EAAAA,UAAU,EAAE,UAASF,IAAT,EAAe;AACvB,WAAOlB,KAAK,CAACqB,WAAN,CAAkB,QAAlB,EAA4B,KAAKC,QAAL,CAAcJ,IAAd,CAA5B,CAAP;AACH,GAlEkB;;AAmEnB;;;;;AAKAI,EAAAA,QAAQ,EAAE,UAASJ,IAAT,EAAe,CACrB;AACH,GA1EkB;;AA2EnB;;;;;AAKAK,EAAAA,oBAAoB,EAAE,UAASC,GAAT,EAAc,CAChC;AACH,GAlFkB;;AAmFnB;;;;AAIAC,EAAAA,QAAQ,EAAE,YAAW;AACjB,QAAIC,OAAO,GAAG,KAAKT,OAAL,CAAa,CAAb,CAAd;AACA,WAAO,IAAIU,IAAJ,CACP,CAAED,OAAO,IAAI,EAAZ,GAAkB,IAAnB,IAA2B,IADpB,EAC0B;AACjC,KAAEA,OAAO,IAAI,EAAZ,GAAkB,IAAnB,IAA2B,CAFpB,EAEuB;AAC7BA,IAAAA,OAAO,IAAI,EAAZ,GAAkB,IAHX,EAGiB;AACvBA,IAAAA,OAAO,IAAI,EAAZ,GAAkB,IAJX,EAIiB;AACvBA,IAAAA,OAAO,IAAI,CAAZ,GAAiB,IALV,EAKgB;AACvB,KAACA,OAAO,GAAG,IAAX,KAAoB,CANb,CAAP,CAFiB,CAQO;AAC3B;AAhGkB,CAAvB;AAkGAE,MAAM,CAACC,OAAP,GAAiB3B,UAAjB","sourcesContent":["'use strict';\nvar utils = require('./utils');\n\nfunction DataReader(data) {\n    this.data = null; // type : see implementation\n    this.length = 0;\n    this.index = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specifed index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1); // second\n    }\n};\nmodule.exports = DataReader;\n"]},"metadata":{},"sourceType":"script"}